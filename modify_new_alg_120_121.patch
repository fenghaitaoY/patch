diff --git a/buildenv/public/prebuild.mk b/buildenv/public/prebuild.mk
index ce171a1..995a403 100644
--- a/buildenv/public/prebuild.mk
+++ b/buildenv/public/prebuild.mk
@@ -125,10 +125,10 @@ LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
 ifneq ($(filter A121,$(sensor))$(filter A120,$(sensor)),)
-    LOCAL_SRC_FILES := prebuild/android/libafs120-$(LIB_SUFFIX).a
+    LOCAL_SRC_FILES := prebuild/android/libalg120-$(LIB_SUFFIX).a
     LOCAL_MODULE := afs120
 else
-    LOCAL_SRC_FILES := prebuild/android/libafs120-$(LIB_SUFFIX).a
+    LOCAL_SRC_FILES := prebuild/android/libalg120-$(LIB_SUFFIX).a
     LOCAL_MODULE := null
 endif
 ifneq ($(LOCAL_MODULE), null)
diff --git a/fingerprint/client/libfprint/utils/ma_utils.c b/fingerprint/client/libfprint/utils/ma_utils.c
index 1278533..e1a6d06 100644
--- a/fingerprint/client/libfprint/utils/ma_utils.c
+++ b/fingerprint/client/libfprint/utils/ma_utils.c
@@ -61,6 +61,7 @@ static void init_properties_sensor121(int cover_type, microarray_properties_t *p
     properties->auth_score = property_get_int32(KEY_AUTH_SCORE, DEFAULT_AUTHENTICATE_SCORE_A121);
     properties->auth_level = property_get_int32(KEY_AUTH_LEVEL, DEFAULT_AUTHENTICATE_LEVEL_A121);
     properties->auth_characteristic_num = property_get_int32(KEY_AUTH_CHARACTERISTIC_NUM, DEFAULT_AUTHENTICATE_CHARACTERISTIC_NUM_A121);
+    properties->update_score = property_get_int32(KEY_UPDATE_SCORE, DEFAULT_AUTHENTICATE_UPDATE_SCORE_A121);
 }
 #endif
 
@@ -82,6 +83,7 @@ static void init_properties_sensor120(int cover_type, microarray_properties_t *p
     properties->auth_score = property_get_int32(KEY_AUTH_SCORE, DEFAULT_AUTHENTICATE_SCORE_A120);
     properties->auth_level = property_get_int32(KEY_AUTH_LEVEL, DEFAULT_AUTHENTICATE_LEVEL_A120);
     properties->auth_characteristic_num = property_get_int32(KEY_AUTH_CHARACTERISTIC_NUM, DEFAULT_AUTHENTICATE_CHARACTERISTIC_NUM_A120);
+    properties->update_score = property_get_int32(KEY_UPDATE_SCORE, DEFAULT_AUTHENTICATE_UPDATE_SCORE_A120);
 }
 #endif
 
diff --git a/fingerprint/include/config.h b/fingerprint/include/config.h
index 90b2744..792b903 100644
--- a/fingerprint/include/config.h
+++ b/fingerprint/include/config.h
@@ -49,9 +49,11 @@ enum navigation_result {
 //#define TEMPLATE_SIZE 3664
 #define DEFAULT_ENERGY_THRESHOLD_A121                    200
 #define DEFAULT_DETECT_THRESHOLD_A121                    128
-#define DEFAULT_AUTHENTICATE_SCORE_A121                  75
+#define DEFAULT_AUTHENTICATE_SCORE_A121                  3000
 #define DEFAULT_AUTHENTICATE_LEVEL_A121                  4
 #define DEFAULT_AUTHENTICATE_CHARACTERISTIC_NUM_A121     1
+#define TEMPLATE_NUM_A121                                100
+#define DEFAULT_AUTHENTICATE_UPDATE_SCORE_A121           6000
 #endif
 
 #ifdef A120
@@ -59,9 +61,11 @@ enum navigation_result {
 #define DEFAULT_ENERGY_THRESHOLD_A120                    1
 #define DEFAULT_DETECT_THRESHOLD_A120                    128
 #define DEFAULT_DETECT_THRESHOLD_A120T                   64
-#define DEFAULT_AUTHENTICATE_SCORE_A120                  75
+#define DEFAULT_AUTHENTICATE_SCORE_A120                  3000
 #define DEFAULT_AUTHENTICATE_LEVEL_A120                  4
 #define DEFAULT_AUTHENTICATE_CHARACTERISTIC_NUM_A120     1
+#define TEMPLATE_NUM_A120                                100
+#define DEFAULT_AUTHENTICATE_UPDATE_SCORE_A120           6000
 #endif
 
 #ifdef A96
diff --git a/fingerprint/service/soft_sensor/sensor120/algorithm/afs120.h b/fingerprint/service/soft_sensor/sensor120/algorithm/afs120.h
index cc90946..dcf283d 100644
--- a/fingerprint/service/soft_sensor/sensor120/algorithm/afs120.h
+++ b/fingerprint/service/soft_sensor/sensor120/algorithm/afs120.h
@@ -5,59 +5,62 @@
  *      Author: lyy
  */
 
-#ifndef AFS120_H_
-#define AFS120_H_
+#ifndef ALG120_H_
+#define ALG120_H_
 
-/* 分配内存
- * @return 成功1， 失败0
- */
-extern int afs_malloc(void);
-
-/* 释放内存
- * @return 成功：0
+/* 功能: 增强 (未实现)
+ *
  */
-extern int afs_free(void);
+extern int alg120_enhance(void *src, void *out);
 
-/* 增强图
- * @src 去背景图
- * @out 增强图
- * @return 指纹质量分数
+/* 提取图像特征模板
+ * @src
+ * @return 特征点个数
  */
-extern int afs_enhance(void *src, void *out);
+extern int alg120_extract(void *src);
 
-/* 注册
- * @src 数据(传入数据改变内部改变)
- * @temp 指纹模版
- * @tnum 指纹模板个数
- * @return -1参数错误，0失败，>0正确
+/* 功能: 注册指纹
+ * @temp 指纹模板
+ * @tnum 单个指纹最大模板数
+ * @emptyArea 未重叠区域
+ * @enrollID 注册模板号
+ * @return （0～10）注册分数
+ * 		   -1 参数错误
  */
-extern int afs_enroll(void *src, void *temp, int tnum);
+extern int alg120_enroll(int *temp, int tnum, int *emptyArea, int *enrollID);
 
-/* 匹配
- * @src 数据
- * @temp 指纹模版
- * @tnum 指纹模板个数
- * @level 等级1~5由低到高
- * @score 匹配分数
- * @snum 匹配模板个数
- * @return -1参数错误，0失败，>0正确
+/* 功能: 匹配指纹
+ * @temp 指纹模板
+ * @tnum 单个指纹最大模板数
+ * @matchArea 重叠区域(输入为匹配面积阀值，输出未匹配面积
+ * @matchID 匹配模板号
+ * @update 更新指纹模板标志
+ * @isMult 是否为多个特征点
+ * @return 匹配分数
+ * 		 	-1 参数错误
  */
-extern int afs_match(void *src, void *temp, int tnum, int level, int *score, int *snum);
+extern int alg120_match(int *temp, int tnum, int *score, int *matchArea, int *matchID, int update, int isMult);
 
 /* 清除
  * @tnum 指纹模板个数
- * @tnum 指纹ID
- * @return -1参数错误，0成功
+ * @return 0成功
+ * 			-1参数错误
  */
-extern int afs_clear(void *temp, int tnum);
+extern int alg120_clear(int *temp, int tnum);
 
 /* 检测注册状态
  * @temp 每个手指模版指针
  * @size 每个手指模版大小
  * @return 注册模版数
  */
-extern int afs_getState(void *temp, int tnum);
+extern int alg120_getState(int *temp, int tnum);
+
+#endif /* ALG120_H_ */
+
+
+
+
+
 
 
-#endif /* AFS120_H_ */
 
diff --git a/fingerprint/service/soft_sensor/sensor120/sensor120_config.h b/fingerprint/service/soft_sensor/sensor120/sensor120_config.h
index 23cb15d..2f47838 100644
--- a/fingerprint/service/soft_sensor/sensor120/sensor120_config.h
+++ b/fingerprint/service/soft_sensor/sensor120/sensor120_config.h
@@ -7,14 +7,14 @@
 #define IMAGE_W     120
 #define IMAGE_H     120
 #define IMAGE_SIZE (IMAGE_W*IMAGE_H)
-#define TEMPLATE_SIZE 3664
+#define TEMPLATE_SIZE_A120  6656
 struct fp_template {
 	uint32_t used; // 是否已经
 	uint32_t fid; // 注册是生成的随机数
 	uint32_t match_pass_count; // 当前对应的匹配成功次数
 	uint64_t user_id;
 	char name[NAME_LENGTH]; // 指纹名-传入
-	uint8_t data[TEMPLATE_SIZE * TEMPLATE_NUM]; // 模版数据-传入
+	int data[TEMPLATE_SIZE_A120 *TEMPLATE_NUM_A120 +1]; // 模版数据-传入
 };
 
 #endif
diff --git a/fingerprint/service/soft_sensor/sensor120/sensor_wrapper.c b/fingerprint/service/soft_sensor/sensor120/sensor_wrapper.c
index 7a4c391..cf232b1 100644
--- a/fingerprint/service/soft_sensor/sensor120/sensor_wrapper.c
+++ b/fingerprint/service/soft_sensor/sensor120/sensor_wrapper.c
@@ -18,15 +18,19 @@
 #include "policy.h"
 static struct fp_template template[FINGERPRINT_SIZE];
 
+static int g_init_enroll = 1;
+static int s_update_flag = 1;
+
 typedef struct enroll_context
 {
     uint32_t finger_id;
 
-    int max_score;
+    int max_count;
     unsigned char max_image[IMAGE_SIZE];
-    unsigned char tmp_template[TEMPLATE_SIZE*TEMPLATE_NUM];
-    unsigned char template_data[TEMPLATE_SIZE*TEMPLATE_NUM];
-    unsigned char test_template_data[TEMPLATE_SIZE*TEMPLATE_NUM];
+    int tmp_template[TEMPLATE_SIZE_A120 * TEMPLATE_NUM_A120 + 1];
+    int template_data[TEMPLATE_SIZE_A120 * TEMPLATE_NUM_A120 + 1];
+    int test_template_data[TEMPLATE_SIZE_A120 * TEMPLATE_NUM_A120 + 1];
+
 } enroll_context_t;
 
 typedef struct authenticate_context
@@ -250,10 +254,10 @@ static int sensor120_create(microarray_properties_t *config)
     g_auth_ctx = malloc(sizeof(authenticate_context_t));
     g_navi_ctx = malloc(sizeof(navigation_context_t));
 
-    ret = afs_malloc();
+    /*ret = afs_malloc();
     if ( ret == 0 ) {
         return ERROR_AFS_MALLOC_FAIL;
-    }
+    }*/
 
     ret = init_sensor120_context();
     if ( ret ) {
@@ -294,7 +298,7 @@ static int sensor120_create(microarray_properties_t *config)
  */
 static int sensor120_destory(void)
 {
-    afs_free();
+    //afs_free();
     free(g_enroll_ctx);
     free(g_auth_ctx);
     free(g_navi_ctx);
@@ -303,6 +307,42 @@ static int sensor120_destory(void)
 
 /******************************algorithm interface******************************/
 
+static int match_save_bmp(int val,int char_num) {
+#ifdef _SAVE_AUTH_IMAGE
+    extern unsigned char *g_image_buffer;
+    char name[128];
+    static int num = 0;
+
+    if(val>0) {
+        LOGD("/data/system/users/0/fpdata/match_succ_%.3d.bmp",num);
+        sprintf(name, "/data/system/users/0/fpdata/match_succ_%.3d.bmp", num);
+    } else {
+        LOGD("/data/system/users/0/fpdata/match_fail_%.4d.bmp",num);
+        sprintf(name, "/data/system/users/0/fpdata/match_%.3d_fail_%d.bmp", num,char_num);
+    }
+    save_bmp_file(name, g_auth_ctx->remove_bkg_img, IMAGE_W, IMAGE_H);
+
+    if(val>0){
+        sprintf(name, "/data/system/users/0/fpdata/match_%3d.txt",num);
+    }else{
+        sprintf(name, "/data/system/users/0/fpdata/match_%.3d_fail_%d.txt",num,char_num);
+    }
+    save_rawdata_file(name, g_image_buffer, IMAGE_W, IMAGE_H);
+
+    if(num%20 ==0){
+        sprintf(name, "/data/system/users/0/fpdata/bkg_%.3d.txt",num);
+        int *bkg = context_get_sensor121_bkg();
+        sava_rawdata_file(name,bkg,IMAGE_W,IMAGE_H);
+    }
+
+    if(num<999) num++;
+    else{
+        num =0;
+        LOGD("reset num");
+    }
+#endif
+    return 0;
+}
 /* 纹理按压检测
  * @image_in:采集到的原图
  * @return  PRESSED：按压
@@ -373,6 +413,22 @@ static int algorithm120_get_energy(void *image_in)
     return ret;
 }
 
+static int do_match_result(int snum, int score, int area) {
+    int ret = 0;
+    if(score>g_config.auth_score) {
+        if(area>320) ret = 1;
+    }
+    return ret;
+}
+
+static int do_match_update(int snum, int score, int area) {
+    int ret=0;
+    if(score>g_config.update_score) {
+         if(area>420) ret = 1;
+     }
+    return ret;
+}
+
 /* 验证
  * @fid_count:现有指纹数量
  * @return  >0:验证成功的fid
@@ -380,40 +436,65 @@ static int algorithm120_get_energy(void *image_in)
  */
 static int algorithm120_authenticate(int *fid_count)
 {
-
-    int val=0, ret=0;
-    int len=0, score=0, snum=0;
-    unsigned char *tmp_img = (unsigned char *)context_get_img_buf();
+    const int areaTH = 400;
+    int val=0, ret=0,temp_num = 0;
+    int pre_len = 0,len=0, score=0, area=0, char_num=0, temp_idx = 0;
+    int last_len=-1,last_score=0,last_area=0, last_temp_idx=0,last_temp_num=0;
     uint32_t fidlist[FINGERPRINT_SIZE];
-    unsigned char *template_data = g_enroll_ctx->tmp_template;
-    memset(template_data, 0, TEMPLATE_SIZE*TEMPLATE_NUM);
+    int *tmp_data = g_enroll_ctx->tmp_template;
+    int *max_data = g_enroll_ctx->test_template_data;
 
-    memcpy(tmp_img, g_auth_ctx->remove_bkg_img, IMAGE_SIZE);
+    int isMult = 1, count_down = *fid_count;
+    char_num = alg120_extract(g_auth_ctx->remove_bkg_img);
     //1.enumate template
-    policy_enumerate_fingerid(fidlist, &len);
-    *fid_count = len;
+    policy_enumerate_fingerid(fidlist, &pre_len);
+    *fid_count = pre_len;
+match_again:
+    memset(tmp_data, 0, sizeof(g_enroll_ctx->tmp_template));
+    memset(max_data, 0, sizeof(g_enroll_ctx->test_template_data));
+    len = pre_len;
     //2.authenticate
     while ( len-- )
     {
-        policy_get_template_data(fidlist[len], template_data);
+        area = areaTH;
+        policy_get_template_data(fidlist[len], tmp_data);
         //注意：afs_match改变了src内数据
-#ifdef _SAVE_READ_IMAGE
-	{
-		static int count=0;
-		char name[100]={0};
-		sprintf(name, "/data/system/users/0/fpdata/match_in_%.5d.bmp", count++);
-		save_bmp_file(name, tmp_img, IMAGE_W, IMAGE_H);
-	}
-#endif
-        val = afs_match(tmp_img, template_data, TEMPLATE_NUM, g_config.auth_level, &score, &snum);
-        LOGD("score=%d, characteristic_num=%d, score_threshold=%d, characteristic_threshold=%d, val=%d.\n",
-             score, snum, g_config.auth_score, g_config.auth_characteristic_num, val);
-        if (score > g_config.auth_score && snum > g_config.auth_characteristic_num) {
-            policy_update_template_data(fidlist[len], template_data);
-            ret = fidlist[len];
-            break;
+        val = alg120_match(tmp_data, TEMPLATE_NUM_A120, &score, &area, &temp_idx, s_update_flag,isMult);
+        temp_num = alg120_getState(tmp_data, TEMPLATE_NUM_A120);
+        if(do_match_result(char_num, score, area)){
+            LOGD("score=%d, last_score = %d,char_num=%d, matchArea=%d score_th=%d, char_th=%d, temp_num=%d\n",
+                    score, last_score, char_num, area, g_config.auth_score, g_config.auth_characteristic_num, temp_num);
+            if(score > last_score) {//更新条件
+                memcpy(max_data, tmp_data, sizeof(g_enroll_ctx->tmp_template));
+                ret = fidlist[len];
+                last_len = len;
+                last_score = score;
+                last_area = area;
+                last_temp_num = temp_num;
+                last_temp_idx = temp_idx;
+            }
         }
     }
+    if(ret != 0) {
+        LOGD("score=%d, char_num=%d, matchArea=%d score_th=%d,temp_idx=%d,temp_num=%d, isMult=%d\n",
+                last_score, char_num, last_area, g_config.auth_score, last_temp_idx, last_temp_num,isMult);
+        match_save_bmp(ret, char_num);
+        LOGD("match successfully.");
+    } else {
+        if(isMult == 1){
+            isMult = 0;
+            goto match_again;
+        }else if(count_down == 0){
+            match_save_bmp(ret, char_num);
+            LOGD("score=%d, char_num=%d, matchArea=%d,score_th=%d\n",score,char_num,area,g_config.auth_score);
+            LOGD("match failed.");
+        }
+    }
+    if(do_match_update(char_num, last_score, last_area) ) { //更新模板
+        policy_update_template_data(fidlist[last_len], max_data);
+        LOGD("update template.\n");
+    }
+    memset(max_data, 0, sizeof(g_enroll_ctx->test_template_data));
     //3.return
     return ret;
 }
@@ -423,10 +504,11 @@ static int algorithm120_authenticate(int *fid_count)
  */
 static int algorithm120_enroll_start(uint64_t user_id)
 {
-    g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-    memset(g_enroll_ctx->template_data, 0, TEMPLATE_SIZE * TEMPLATE_NUM);
+    g_enroll_ctx->max_count = 0;
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    memset(g_enroll_ctx->template_data, 0, sizeof(g_enroll_ctx->template_data));
     g_enroll_ctx->finger_id = policy_generate_id(user_id);
+    g_init_enroll = 1;
     return g_enroll_ctx->finger_id;
 }
 
@@ -437,18 +519,25 @@ static int algorithm120_enroll_start(uint64_t user_id)
 
 static int algorithm120_enroll(void)
 {
-    int ret = SUCCESS, fid_count = 0;
+    int ret = SUCCESS, fid_count = -1, temp_idx=0, char_num=0, area=-1;
     unsigned char *enroll_image = (unsigned char *)context_get_img_buf();
 
+    s_update_flag = 0;
     fp120_remove_bkg(g_enroll_ctx->max_image, context_get_sensor120_bkg(), enroll_image);
-
-    if( g_config.filter_duplicate_enroll )
-    {
-        memcpy(g_auth_ctx->remove_bkg_img, enroll_image, IMAGE_SIZE);
-        if ( algorithm120_authenticate(&fid_count) )
-        {
-            g_enroll_ctx->max_score = 0;
+    memcpy(g_auth_ctx->remove_bkg_img, enroll_image, IMAGE_SIZE);
+    char_num = alg120_extract(g_auth_ctx->remove_bkg_img);
+    if(char_num<2){
+        s_update_flag = 1;
+        g_enroll_ctx->max_count = 0;
+        memset(g_enroll_ctx->max_image,0,sizeof(g_enroll_ctx->max_image));
+        return ERROR_ENROLL_FAIL;
+    }
+    if( g_config.filter_duplicate_enroll ){
+        if ( algorithm120_authenticate(&fid_count) ){
             LOGD("duplicate finger.");
+            s_update_flag = 1;
+            g_enroll_ctx->max_count = 0;
+            memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
             return ERROR_ENROLL_DUPLICATE_FINGER;
         }
     }
@@ -471,15 +560,26 @@ sprintf(name, "/data/system/users/0/fpdata/enroll_src_%.5d.bmp", count);
 		count++;}
 	}
 #endif
-	ret = afs_enroll(enroll_image, g_enroll_ctx->template_data, TEMPLATE_NUM);
-	if (ret <= 0 && g_enroll_ctx->max_score != 0) {
-		g_enroll_ctx->max_score = 0;
-		memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-		return ERROR_ENROLL_DUPLICATE_AREA;
-	} else {
-		g_enroll_ctx->max_score = ret;
-		memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-	}
+
+    ret = alg120_enroll(g_enroll_ctx->template_data, TEMPLATE_NUM_A120, &area,&temp_idx);
+    //temp_num = alg120_getState(g_enroll_ctx->template_data,TEMPLATE_NUM_A120);
+    LOGD("enroll ret = %d, emptyArea=%d, char_num=%d, temp_idx=%d",ret,area,char_num,temp_idx);
+
+    s_update_flag = 1;
+    g_enroll_ctx->max_count = 0;
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+
+    if(ret == 0) {
+        if(g_init_enroll == 1) { //第一次注册区域失败不能报重复区域，只能报部分手指
+            LOGD("end. bad image.");
+            return ERROR_ENROLL_FAIL;
+        } else {
+            LOGD("end. duplicate area.");
+            return ERROR_ENROLL_DUPLICATE_AREA;
+        }
+    } else {
+        if(g_init_enroll == 1) g_init_enroll = 0;
+    }
     LOGD("end.");
     return SUCCESS;
 }
@@ -629,17 +729,20 @@ static int sensor120_factory_test_press(void)
  */
 static int sensor120_factory_test_enroll(void)
 {
-    int ret = SUCCESS;
+    int ret = SUCCESS, snum = -1, area = -1, temp_num = 0,temp_idx=0;
     unsigned char *enroll_image = (unsigned char *)context_get_img_buf();
     LOGD("start.\n");
     fp120_remove_bkg(g_enroll_ctx->max_image, context_get_sensor120_bkg(), enroll_image);
-    ret = afs_enroll(enroll_image, g_enroll_ctx->test_template_data, TEST_TEMPLATE_NUM);
-    g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
+    snum = alg120_extract(enroll_image);
+    ret = alg120_enroll(g_enroll_ctx->test_template_data,TEMPLATE_NUM_A120,&area,&temp_idx);
+    //temp_num = alg120_getState(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A120);
+    g_enroll_ctx->max_count = 0;
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    ret = ret<=2? 0: ret;
     if (ret == 0) {
-        return ERROR_ENROLL_DUPLICATE_AREA;
-    }
-    LOGD("end.\n");
+            return ERROR_ENROLL_DUPLICATE_AREA;
+        }
+    LOGD("end. enroll snum=%d area=%d temp_num=%d ret=%d\n", snum, area, temp_num, ret);
     return ret;
 }
 
@@ -649,30 +752,36 @@ static int sensor120_factory_test_enroll(void)
  */
 static int sensor120_factory_test_authenticate(void)
 {
-    int val=0;
-    int score=0, snum=0;
+    int ret = FAIL,temp_num, temp_idx;
+    int val=0, score = 0, snum, area = 320;
 
     unsigned char *tmp_img = (unsigned char *)context_get_img_buf();
-    unsigned char *template_data = g_enroll_ctx->tmp_template;
     LOGD("start.\n");
-    memset(template_data, 0, TEMPLATE_SIZE*TEMPLATE_NUM);
     memcpy(tmp_img, g_auth_ctx->remove_bkg_img, IMAGE_SIZE);
-    memcpy(template_data, g_enroll_ctx->test_template_data, TEMPLATE_SIZE*TEST_TEMPLATE_NUM);
-    val = afs_match(tmp_img, g_enroll_ctx->test_template_data, TEST_TEMPLATE_NUM, g_config.auth_level, &score, &snum);
-    LOGD("match result = %d end.\n", val);
-    LOGD("end.\n");
-    if(score > g_config.auth_score && snum > g_config.auth_characteristic_num) {
-        return SUCCESS;
+    snum = alg120_extract(tmp_img);
+	int isMult = 1;
+test_match_again:
+    val = alg120_match(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A120, &score, &area,&temp_idx, s_update_flag, isMult);
+    temp_num = alg120_getState(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A120);
+    if(score > g_config.auth_score && area > 256){
+        ret = SUCCESS;
+	} else {
+		if (isMult == 1){
+			isMult = 0;
+			goto test_match_again;
+		}
     }
-    return FAIL;
+    LOGD("match val = %d score= %d area = %d snum = %d temp_num = %d ret = %d", val, score,area, snum, temp_num, ret);
+    LOGD("end.\n");
+    return ret;
 }
 
 static int sensor120_factory_test_remove(void)
 {
     LOGD("start.\n");
-    g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-    memset(g_enroll_ctx->test_template_data, 0, TEMPLATE_SIZE*TEST_TEMPLATE_NUM);
+    g_enroll_ctx->max_count = 0;
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    memset(g_enroll_ctx->test_template_data, 0, sizeof(g_enroll_ctx->test_template_data));
     LOGD("end.\n");
     return SUCCESS;
 }
@@ -705,7 +814,8 @@ static int sensor120_factory_test_get_image(void *image)
             }
             memcpy(image_bkg, context_get_sensor120_bkg(), IMAGE_SIZE);
             fp120_remove_bkg(image_in, image_bkg, image_out);
-            afs_enhance(image_out, image_enhance);
+            //afs_enhance(image_out, image_enhance);
+            alg120_enhance(image_out, image_enhance);
             read_bmp_head(img, 1078, IMAGE_W, IMAGE_H);
             memcpy(img + 1078, image_in, IMAGE_SIZE);
             read_bmp_head(img + len, 1078, IMAGE_W, IMAGE_H);
@@ -744,7 +854,7 @@ int init_sensor120(soft_sensor_t *sensor) {
     sensor->image_buffer                        = protocol_image_buffer;
 
     sensor->template_head                       = template;
-    sensor->policy_data_size                    = sizeof(struct fp_template_head) + TEMPLATE_SIZE*TEMPLATE_NUM;
+    sensor->policy_data_size                    = sizeof(struct fp_template_head) + (TEMPLATE_SIZE_A120*TEMPLATE_NUM_A120+1) * sizeof(int);
 
     sensor->sensor_create                       = sensor120_create;
     sensor->sensor_destory                      = sensor120_destory;
diff --git a/fingerprint/service/soft_sensor/sensor121/algorithm/afs120.h b/fingerprint/service/soft_sensor/sensor121/algorithm/afs120.h
index 449cccf..4513166 100644
--- a/fingerprint/service/soft_sensor/sensor121/algorithm/afs120.h
+++ b/fingerprint/service/soft_sensor/sensor121/algorithm/afs120.h
@@ -1,63 +1,66 @@
 /*
- * afslib.h
+ * alg120.h
  *
  *  Created on: 2014-11-29
  *      Author: lyy
  */
 
-#ifndef AFSLIB_H_
-#define AFSLIB_H_
+#ifndef ALG120_H_
+#define ALG120_H_
 
-/* 分配内存
- * @return 成功1， 失败0
- */
-extern int afs_malloc(void);
-
-/* 释放内存
- * @return 成功：0
+/* 功能: 增强 (未实现)
+ *
  */
-extern int afs_free(void);
+extern int alg120_enhance(void *src, void *out);
 
-/* 增强图
- * @src 去背景图
- * @out 增强图
- * @return 指纹质量分数
+/* 提取图像特征模板
+ * @src
+ * @return 特征点个数
  */
-extern int afs_enhance(void *src, void *out);
+extern int alg120_extract(void *src);
 
-/* 注册
- * @src 数据(传入数据改变内部改变)
- * @temp 指纹模版
- * @tnum 指纹模板个数
- * @return -1参数错误，0失败，>0正确
+/* 功能: 注册指纹
+ * @temp 指纹模板
+ * @tnum 单个指纹最大模板数
+ * @emptyArea 未重叠区域
+ * @enrollID 注册模板号
+ * @return （0～10）注册分数
+ * 		   -1 参数错误
  */
-extern int afs_enroll(void *src, void *temp, int tnum);
+extern int alg120_enroll(int *temp, int tnum, int *emptyArea, int *enrollID);
 
-/* 匹配
- * @src 数据
- * @temp 指纹模版
- * @tnum 指纹模板个数
- * @level 等级1~5由低到高
- * @score 匹配分数
- * @snum 匹配模板个数
- * @return -1参数错误，0失败，>0正确
+/* 功能: 匹配指纹
+ * @temp 指纹模板
+ * @tnum 单个指纹最大模板数
+ * @matchArea 重叠区域(输入为匹配面积阀值，输出未匹配面积
+ * @matchID 匹配模板号
+ * @update 更新指纹模板标志
+ * @isMult 是否为多个特征点
+ * @return 匹配分数
+ * 		 	-1 参数错误
  */
-extern int afs_match(void *src, void *temp, int tnum, int level, int *score, int *snum);
+extern int alg120_match(int *temp, int tnum, int *score, int *matchArea, int *matchID, int update, int isMult);
 
 /* 清除
  * @tnum 指纹模板个数
- * @tnum 指纹ID
- * @return -1参数错误，0成功
+ * @return 0成功
+ * 			-1参数错误
  */
-extern int afs_clear(void *temp, int tnum);
+extern int alg120_clear(int *temp, int tnum);
 
 /* 检测注册状态
  * @temp 每个手指模版指针
  * @size 每个手指模版大小
  * @return 注册模版数
  */
-extern int afs_getState(void *temp, int tnum);
+extern int alg120_getState(int *temp, int tnum);
+
+#endif /* ALG120_H_ */
+
+
+
+
+
 
 
-#endif /* AFSLIB_H_ */
 
diff --git a/fingerprint/service/soft_sensor/sensor121/sensor121_config.h b/fingerprint/service/soft_sensor/sensor121/sensor121_config.h
index cf21866..51e5d73 100644
--- a/fingerprint/service/soft_sensor/sensor121/sensor121_config.h
+++ b/fingerprint/service/soft_sensor/sensor121/sensor121_config.h
@@ -7,7 +7,7 @@
 #define IMAGE_W     120
 #define IMAGE_H     120
 #define IMAGE_SIZE (IMAGE_W*IMAGE_H)
-#define TEMPLATE_SIZE 3664
+#define TEMPLATE_SIZE_A121 6656
 
 struct fp_template {
 	uint32_t used; // 是否已经
@@ -15,7 +15,7 @@ struct fp_template {
 	uint32_t match_pass_count; // 当前对应的匹配成功次数
 	uint64_t user_id;
 	char name[NAME_LENGTH]; // 指纹名-传入
-	uint8_t data[TEMPLATE_SIZE * TEMPLATE_NUM]; // 模版数据-传入
+	int data[TEMPLATE_SIZE_A121 * TEMPLATE_NUM_A121 +1]; // 模版数据-传入
 };
 
 #endif
diff --git a/fingerprint/service/soft_sensor/sensor121/sensor_wrapper.c b/fingerprint/service/soft_sensor/sensor121/sensor_wrapper.c
index 495c19a..59272c2 100644
--- a/fingerprint/service/soft_sensor/sensor121/sensor_wrapper.c
+++ b/fingerprint/service/soft_sensor/sensor121/sensor_wrapper.c
@@ -19,15 +19,18 @@
 
 static struct fp_template template[FINGERPRINT_SIZE];
 
+static int g_init_enroll = 1;
+static int s_update_flag = 1;
+
 typedef struct enroll_context
 {
     uint32_t finger_id;
 
     int max_score;
     unsigned char max_image[IMAGE_SIZE];
-    unsigned char tmp_template[TEMPLATE_SIZE*TEMPLATE_NUM];
-    unsigned char template_data[TEMPLATE_SIZE*TEMPLATE_NUM];
-    unsigned char test_template_data[TEMPLATE_SIZE*TEMPLATE_NUM];
+    int tmp_template[TEMPLATE_SIZE_A121*TEMPLATE_NUM_A121 +1];
+    int template_data[TEMPLATE_SIZE_A121*TEMPLATE_NUM_A121 +1];
+    int test_template_data[TEMPLATE_SIZE_A121*TEMPLATE_NUM_A121+1];
 } enroll_context_t;
 
 typedef struct authenticate_context
@@ -235,11 +238,11 @@ static int sensor121_create(microarray_properties_t *config)
     g_auth_ctx = malloc(sizeof(authenticate_context_t));
     g_navi_ctx = malloc(sizeof(navigation_context_t));
 
-    ret = afs_malloc();
+    /*ret = afs_malloc();
     if ( ret == 0 )
     {
         return ERROR_AFS_MALLOC_FAIL;
-    }
+    }*/
 
     ret = init_sensor121_context();
     if ( ret )
@@ -275,7 +278,7 @@ static int sensor121_create(microarray_properties_t *config)
  */
 static int sensor121_destory(void)
 {
-    afs_free();
+    //afs_free();
     free(g_enroll_ctx);
     free(g_auth_ctx);
     free(g_navi_ctx);
@@ -284,6 +287,43 @@ static int sensor121_destory(void)
 
 /******************************algorithm interface******************************/
 
+static int match_save_bmp(int val,int char_num) {
+#ifdef _SAVE_AUTH_IMAGE
+    extern unsigned char *g_image_buffer;
+    char name[128];
+    static int num = 0;
+
+    if(val>0) {
+        LOGD("/data/system/users/0/fpdata/match_succ_%.3d.bmp",num);
+        sprintf(name, "/data/system/users/0/fpdata/match_succ_%.3d.bmp", num);
+    } else {
+        LOGD("/data/system/users/0/fpdata/match_fail_%.4d.bmp",num);
+        sprintf(name, "/data/system/users/0/fpdata/match_%.3d_fail_%d.bmp", num,char_num);
+    }
+    save_bmp_file(name, g_auth_ctx->remove_bkg_img, IMAGE_W, IMAGE_H);
+
+    if(val>0){
+        sprintf(name, "/data/system/users/0/fpdata/match_%3d.txt",num);
+    }else{
+        sprintf(name, "/data/system/users/0/fpdata/match_%.3d_fail_%d.txt",num,char_num);
+    }
+    save_rawdata_file(name, g_image_buffer, IMAGE_W, IMAGE_H);
+
+    if(num%20 ==0){
+        sprintf(name, "/data/system/users/0/fpdata/bkg_%.3d.txt",num);
+        int *bkg = context_get_sensor121_bkg();
+        sava_rawdata_file(name,bkg,IMAGE_W,IMAGE_H);
+    }
+
+    if(num<999) num++;
+    else{
+        num =0;
+        LOGD("reset num");
+    }
+#endif
+    return 0;
+}
+
 /* 纹理按压检测
  * @image_in:采集到的原图
  * @return  PRESSED：按压
@@ -297,6 +337,7 @@ static int algorithm121_press_detect_texture(void *image_in, int type)
     LOGD("start.\n");
     fp121_remove_bkg((unsigned char *)image_in, context_get_sensor121_bkg(), g_auth_ctx->remove_bkg_img);
     memcpy(img, g_auth_ctx->remove_bkg_img, IMAGE_SIZE);
+
     dtc = fp121_press_detect_texture(img, g_config.detect_threshold, &weight);
     LOGD("------------------dtc = %d \n",dtc);
     ret = ( dtc == 1 ) ? NORMAL_PRESSED : NORMAL_UNPRESSED;
@@ -356,6 +397,23 @@ static int algorithm121_get_energy(void *image)
     return score;
 }
 
+static int do_match_result(int snum, int score, int area){
+    int ret = 0;
+    if(score > g_config.auth_score){
+        //if(area>320) ret = 1;
+        ret = 1;
+    }
+    return ret;
+}
+
+static int do_match_update(int snum, int score, int area){
+    int ret=0;
+    if(score>g_config.update_score){
+        if(area > 420) ret = 1;
+    }
+    return ret;
+}
+
 /* 验证
  * @fid_count:现有指纹数量
  * @return  >0:验证成功的fid
@@ -363,32 +421,65 @@ static int algorithm121_get_energy(void *image)
  */
 static int algorithm121_authenticate(int *fid_count)
 {
-
-    int val=0, ret=0;
-    int len=0, score=0, snum=0;
-    unsigned char *tmp_img = (unsigned char *)context_get_img_buf();
+    const int areaTH = 400;
+    int val=0, ret=0,temp_num = 0;
+    int pre_len = 0,len=0, score=0, area=0, char_num=0, temp_idx = 0;
+    int last_len=-1,last_score=0,last_area=0, last_temp_idx=0,last_temp_num=0;
     uint32_t fidlist[FINGERPRINT_SIZE];
-    unsigned char *template_data = g_enroll_ctx->tmp_template;
-    memset(template_data, 0, TEMPLATE_SIZE*TEMPLATE_NUM);
+    int *tmp_data = g_enroll_ctx->tmp_template;
+    int *max_data = g_enroll_ctx->test_template_data;
 
-    memcpy(tmp_img, g_auth_ctx->remove_bkg_img, IMAGE_SIZE);
+    int isMult = 1, count_down = *fid_count;
+    char_num = alg120_extract(g_auth_ctx->remove_bkg_img);
     //1.enumate template
-    policy_enumerate_fingerid(fidlist, &len);
-    *fid_count = len;
+    policy_enumerate_fingerid(fidlist, &pre_len);
+    *fid_count = pre_len;
+match_again:
+    memset(tmp_data, 0, sizeof(g_enroll_ctx->tmp_template));
+    memset(max_data, 0, sizeof(g_enroll_ctx->test_template_data));
+    len = pre_len;
     //2.authenticate
     while ( len-- )
     {
-        policy_get_template_data(fidlist[len], template_data);
+        area = areaTH;
+        policy_get_template_data(fidlist[len], tmp_data);
         //注意：afs_match改变了src内数据
-        val = afs_match(tmp_img, template_data, TEMPLATE_NUM, g_config.auth_level, &score, &snum);
-        LOGD("score=%d, characteristic_num=%d, score_threshold=%d, characteristic_threshold=%d, val=%d.\n",
-             score, snum, g_config.auth_score, g_config.auth_characteristic_num, val);
-        if (score > g_config.auth_score && snum > g_config.auth_characteristic_num) {
-            policy_update_template_data(fidlist[len], template_data);
-            ret = fidlist[len];
-            break;
+        val = alg120_match(tmp_data, TEMPLATE_NUM_A121, &score, &area, &temp_idx, s_update_flag,isMult);
+        temp_num = alg120_getState(tmp_data, TEMPLATE_NUM_A121);
+        if(do_match_result(char_num, score, area)){
+            LOGD("score=%d, last_score = %d,char_num=%d, matchArea=%d score_th=%d, char_th=%d, temp_num=%d\n",
+                    score, last_score, char_num, area, g_config.auth_score, g_config.auth_characteristic_num, temp_num);
+            if(score > last_score) {//更新条件
+                memcpy(max_data, tmp_data, sizeof(g_enroll_ctx->tmp_template));
+                ret = fidlist[len];
+                last_len = len;
+                last_score = score;
+                last_area = area;
+                last_temp_num = temp_num;
+                last_temp_idx = temp_idx;
+            }
+        }
+    }
+    if(ret != 0) {
+        LOGD("score=%d, char_num=%d, matchArea=%d score_th=%d,temp_idx=%d,temp_num=%d, isMult=%d\n",
+                last_score, char_num, last_area, g_config.auth_score, last_temp_idx, last_temp_num,isMult);
+        match_save_bmp(ret, char_num);
+        LOGD("match successfully.");
+    } else {
+        if(isMult == 1){
+            isMult = 0;
+            goto match_again;
+        }else if(count_down == 0){
+            match_save_bmp(ret, char_num);
+            LOGD("score=%d, char_num=%d, matchArea=%d,score_th=%d\n",score,char_num,area,g_config.auth_score);
+            LOGD("match failed.");
         }
     }
+    if(do_match_update(char_num, last_score, last_area) ) { //更新模板
+        policy_update_template_data(fidlist[last_len], max_data);
+        LOGD("update template.\n");
+    }
+    memset(max_data, 0, sizeof(g_enroll_ctx->test_template_data));
     //3.return
     return ret;
 }
@@ -399,9 +490,10 @@ static int algorithm121_authenticate(int *fid_count)
 static int algorithm121_enroll_start(uint64_t user_id)
 {
     g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-    memset(g_enroll_ctx->template_data, 0, TEMPLATE_SIZE * TEMPLATE_NUM);
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    memset(g_enroll_ctx->template_data, 0, sizeof(g_enroll_ctx->template_data));
     g_enroll_ctx->finger_id = policy_generate_id(user_id);
+    g_init_enroll = 1;
     return g_enroll_ctx->finger_id;
 }
 
@@ -411,21 +503,29 @@ static int algorithm121_enroll_start(uint64_t user_id)
  */
 static int algorithm121_enroll(void)
 {
-    int ret = SUCCESS, fid_count = 0;
+    int ret = SUCCESS, fid_count = -1, temp_idx=0, char_num=0, area =-1;
     unsigned char *enroll_image = (unsigned char *)context_get_img_buf();
 
+    s_update_flag = 0;
 #ifdef NEW_AFS121_REMOVE_BKG
     fp121_remove_bkg_expand(g_enroll_ctx->max_image, context_get_sensor121_bkg(),
             enroll_image, s_calc_buf);
 #else
     fp121_remove_bkg(g_enroll_ctx->max_image, context_get_sensor121_bkg(), enroll_image);
 #endif
-    if( g_config.filter_duplicate_enroll )
-    {
-        memcpy(g_auth_ctx->remove_bkg_img, enroll_image, IMAGE_SIZE);
-        if ( algorithm121_authenticate(&fid_count) )
-        {
+    memcpy(g_auth_ctx->remove_bkg_img, enroll_image, IMAGE_SIZE);
+    char_num = alg120_extract(g_auth_ctx->remove_bkg_img);
+    if(char_num<2){
+        s_update_flag = 1;
+        g_enroll_ctx->max_score=0;
+        memset(g_enroll_ctx->max_image,0,sizeof(g_enroll_ctx->max_image));
+        return ERROR_ENROLL_FAIL;
+    }
+    if( g_config.filter_duplicate_enroll ){
+        if ( algorithm121_authenticate(&fid_count) ){
+            s_update_flag = 1;
             g_enroll_ctx->max_score = 0;
+            memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
             LOGD("duplicate finger.");
             return ERROR_ENROLL_DUPLICATE_FINGER;
         }
@@ -437,14 +537,26 @@ static int algorithm121_enroll(void)
 				return ERROR_ENROLL_PART_TOUCH;
 		}
 	}
-	ret = afs_enroll(enroll_image, g_enroll_ctx->template_data, TEMPLATE_NUM);
+    ret = alg120_enroll(g_enroll_ctx->template_data, TEMPLATE_NUM_A121, &area,&temp_idx);
+    //temp_num = alg120_getState(g_enroll_ctx->template_data,TEMPLATE_NUM_A121);
+    LOGD("enroll ret = %d, emptyArea=%d, char_num=%d, temp_idx=%d",ret,area,char_num,temp_idx);
+
+    s_update_flag = 1;
     g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
+    memset(g_enroll_ctx->max_image,0,sizeof(g_enroll_ctx->max_image));
 
-    if ( ret <= 0 )
-    {
-        return ERROR_ENROLL_DUPLICATE_AREA;
+    if(ret == 0){
+        if(g_init_enroll == 1){ //第一次注册区域失败不能报重复区域,只能报部分手指
+            LOGD("end. bad image.");
+            return ERROR_ENROLL_FAIL;
+        } else {
+            LOGD("end. duplicate area.");
+            return ERROR_ENROLL_DUPLICATE_AREA;
+        }
+    } else {
+        if(g_init_enroll == 1) g_init_enroll = 0;
     }
+    LOGD("end");
     return SUCCESS;
 }
 
@@ -800,7 +912,7 @@ static int sensor121_factory_test_press(void)
  */
 static int sensor121_factory_test_enroll(void)
 {
-    int ret = SUCCESS;
+    int ret = SUCCESS, snum = -1, area = -1,temp_idx= 0;
     unsigned char *enroll_image = (unsigned char *)context_get_img_buf();
     LOGD("start.\n");
 #ifdef NEW_AFS121_REMOVE_BKG
@@ -809,13 +921,16 @@ static int sensor121_factory_test_enroll(void)
 #else
     fp121_remove_bkg(g_enroll_ctx->max_image, context_get_sensor121_bkg(), enroll_image);
 #endif
-    ret = afs_enroll(enroll_image, g_enroll_ctx->test_template_data, TEST_TEMPLATE_NUM);
+    snum = alg120_extract(enroll_image);
+    ret = alg120_enroll(g_enroll_ctx->test_template_data,TEMPLATE_NUM_A121,&area,&temp_idx);
+    //temp_num = alg120_getState(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A121);
     g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-    if (ret == 0) {
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    ret = ret <= 2 ? 0 : ret;
+    if(ret == 0){
         return ERROR_ENROLL_DUPLICATE_AREA;
     }
-    LOGD("end.\n");
+    LOGD("end. enroll snum = %d area = %d temp_idx=%d ret = %d\n", snum, area,temp_idx, ret);
     return ret;
 }
 
@@ -825,30 +940,36 @@ static int sensor121_factory_test_enroll(void)
  */
 static int sensor121_factory_test_authenticate(void)
 {
-    int val=0;
-    int score=0, snum=0;
+    int ret = FAIL,temp_num, temp_idx;
+    int val=0, score = 0, snum, area = 320;
 
     unsigned char *tmp_img = (unsigned char *)context_get_img_buf();
-    unsigned char *template_data = g_enroll_ctx->tmp_template;
     LOGD("start.\n");
-    memset(template_data, 0, TEMPLATE_SIZE*TEMPLATE_NUM);
     memcpy(tmp_img, g_auth_ctx->remove_bkg_img, IMAGE_SIZE);
-    memcpy(template_data, g_enroll_ctx->test_template_data, TEMPLATE_SIZE*TEST_TEMPLATE_NUM);
-    val = afs_match(tmp_img, g_enroll_ctx->test_template_data, TEST_TEMPLATE_NUM, g_config.auth_level, &score, &snum);
-    LOGD("match result = %d end.\n", val);
-    LOGD("end.\n");
-    if(score > g_config.auth_score && snum > g_config.auth_characteristic_num) {
-        return SUCCESS;
+    snum = alg120_extract(tmp_img);
+	int isMult = 1;
+test_match_again:
+    val = alg120_match(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A121, &score, &area,&temp_idx, s_update_flag, isMult);
+    temp_num = alg120_getState(g_enroll_ctx->test_template_data, TEMPLATE_NUM_A121);
+    if(score > g_config.auth_score && area > 256){
+        ret = SUCCESS;
+	} else {
+		if (isMult == 1){
+			isMult = 0;
+			goto test_match_again;
+		}
     }
-    return FAIL;
+    LOGD("match val = %d score= %d area = %d snum = %d temp_num = %d ret = %d", val, score,area, snum, temp_num, ret);
+    LOGD("end.\n");
+    return ret;
 }
 
 static int sensor121_factory_test_remove(void)
 {
     LOGD("start.\n");
     g_enroll_ctx->max_score = 0;
-    memset(g_enroll_ctx->max_image, 0, IMAGE_SIZE);
-    memset(g_enroll_ctx->test_template_data, 0, TEMPLATE_SIZE*TEST_TEMPLATE_NUM);
+    memset(g_enroll_ctx->max_image, 0, sizeof(g_enroll_ctx->max_image));
+    memset(g_enroll_ctx->test_template_data, 0, sizeof(g_enroll_ctx->test_template_data));
     LOGD("end.\n");
     return SUCCESS;
 }
@@ -886,7 +1007,7 @@ static int sensor121_factory_test_get_image(void *image)
 #else
             fp121_remove_bkg(image_in, image_bkg, image_out);
 #endif
-            afs_enhance(image_out, image_enhance);
+            alg120_enhance(image_out, image_enhance);
          
             read_bmp_head(img, 1078, IMAGE_W, IMAGE_H);
             memcpy(img + 1078, image_in, IMAGE_SIZE);
@@ -929,7 +1050,7 @@ int init_sensor121(soft_sensor_t *sensor) {
     sensor->image_buffer                        = protocol_image_buffer;
 
     sensor->template_head                       = template;
-    sensor->policy_data_size                    = sizeof(struct fp_template_head) + TEMPLATE_SIZE*TEMPLATE_NUM;
+    sensor->policy_data_size                    = sizeof(struct fp_template_head) + (TEMPLATE_SIZE_A121*TEMPLATE_NUM_A121 +1 ) * sizeof(int);
 
     sensor->sensor_create                       = sensor121_create;
     sensor->sensor_destory                      = sensor121_destory;
diff --git a/version/product.csv b/version/product.csv
index 4b1dc52..7b0be2e 100644
--- a/version/product.csv
+++ b/version/product.csv
@@ -1,6 +1,6 @@
 Product,OEM,Version,Support Sensor,Platform,APP ABI,Operation System,Enable Navigation,Return After Authenticate,Filter Duplicate Enroll,Filter Part Touch Enroll,Enroll Times,Auth Retry Times
 E281,Yude,4.0.1,A121_N,Trustkernel,arm64-v8a,Android6.0,No,Yes,Yes,Yes,25,3
-X601,Chuanyin,4.0.07,A121_N,Android,arm64-v8a armeabi,Android6.0,Yes,Yes,Yes,No,14,3
+X601,Chuanyin,4.0.08,A121_N,Android,arm64-v8a armeabi,Android6.0,Yes,Yes,Yes,No,14,3
 E2,Konka,4.0.00,A80_T,YUNOS,arm64-v8a,Android6.0,Yes,Yes,Yes,No,14,3
 Android,Tianyida,4.0.00,A80_T,Android,armeabi,Android6.0,Yes,Yes,Yes,No,14,3
 Android,Tianyida,4.0.00,A121_N&A120_N,Android,arm64-v8a armeabi,Android6.0,Yes,Yes,Yes,No,14,3
diff --git a/version/test.csv b/version/test.csv
index ccd4ac2..e7fce1d 100644
--- a/version/test.csv
+++ b/version/test.csv
@@ -12,6 +12,7 @@ Default,Android,4.0.00,A121_N,Watchtrust,x86_64,Android6.0,Yes,Yes,Yes,No,14,3
 Default,Android,4.0.00,A121_N,Nutlet,arm64-v8a,Android6.0,Yes,Yes,Yes,No,14,3
 Default,Android,4.0.00,A121_N,Microtrust,arm64-v8a,Android6.0,Yes,Yes,Yes,No,14,3
 Default,Android,4.0.00,A83_N,Android,armeabi,Android6.0,Yes,Yes,Yes,No,21,3
+Default,Android,4.0.00,A83_T,Android,armeabi arm64-v8a,Android6.0,Yes,Yes,Yes,No,21,3
 Default,Android,4.0.00,A80_T,Android,armeabi,Android6.0,Yes,Yes,Yes,No,14,3
 Default,Android,4.0.00,A80_T&A83_N,Android,armeabi,Android6.0,Yes,Yes,Yes,No,21,3
 Default,Android,4.0.00,A121_N,Android,arm64-v8a,Ali5.1,Yes,Yes,Yes,No,14,3
